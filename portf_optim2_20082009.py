# -*- coding: utf-8 -*-
"""20082009.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vFmz-KOs2f4jIRtupO7_4WIxUYzXBDBr
"""

# !pip install cplex
# !apt install coinor-libipopt-dev
# !pip install ipopt

import warnings
warnings.filterwarnings("ignore")
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
import cplex
import ipopt

def strat_buy_and_hold(x_init, cash_init, mu, Q, cur_prices):
    x_optimal = x_init
    cash_optimal = cash_init
    return x_optimal, cash_optimal

def strat_equally_weighted(x_init, cash_init, mu, Q, cur_prices):
    total_value = np.dot(cur_prices,x_init)+cash_init
    weight_optimal = np.array([1/len(x_init)]*len(x_init)) # Equal weight = 1/n
    allocated_value = weight_optimal*total_value
    
    x_optimal = np.floor(allocated_value/cur_prices) # Rounding procedure
    transaction_fee = 0.005 * np.dot(cur_prices,abs(x_optimal-x_init))
    cash_optimal = total_value - np.dot(cur_prices,x_optimal) - transaction_fee
    
    return x_optimal, cash_optimal

def strat_min_variance(x_init, cash_init, mu, Q, cur_prices):
    total_value = np.dot(cur_prices,x_init)+cash_init
    
    n = len(x_init)
    
    cpx = cplex.Cplex()
    cpx.objective.set_sense(cpx.objective.sense.minimize) # Minimize objective
    c  = [0.0] * n # No linear objective
    lb = [0.0] * n
    ub = [1.0] * n
    
    Atilde = []
    for k in range(n):
        Atilde.append([[0,1],[1,0]]) # One column of ones times corresponding weights
    
    var_names = ["w_%s" % i for i in range(1,n+1)] 
    cpx.linear_constraints.add(rhs=[1.0,0], senses="EE")                  
    cpx.variables.add(obj=c, lb=lb, ub=ub, columns=Atilde, names=var_names)
    
    qmat = [[list(range(n)), list(2*Q[k,:])] for k in range(n)] # Sparse matrix of Q
    cpx.objective.set_quadratic(qmat) # Quadratic objective
    cpx.parameters.threads.set(6)
    cpx.set_results_stream(None)
    cpx.set_warning_stream(None)
    cpx.solve()
   
    # If no optimal solution exists, do not rebalance
    # Keep the position and cash from last period
    if cpx.solution.get_status_string() == 'infeasible':
        x_optimal = x_init
        cash_optimal = cash_init
    
    else:
    
        weight_optimal = np.array(cpx.solution.get_values())
    
        allocated_value = weight_optimal*total_value
    
        x_optimal = np.floor(allocated_value/cur_prices) #Rounding procedure
        transaction_fee = 0.005 * np.dot(cur_prices,abs(x_optimal-x_init))
        cash_optimal = total_value - np.dot(cur_prices,x_optimal) - transaction_fee
    
    return x_optimal, cash_optimal

def strat_max_Sharpe(x_init, cash_init, mu, Q, cur_prices):
    total_value = np.dot(cur_prices,x_init)+cash_init
    
    n = len(x_init)+1
    daily_rf = r_rf2008_2009/252    # Use 2008-2009 risk free rate
    diff = mu - daily_rf
    
    coe_k = np.zeros((20,1))
    Q = np.hstack((Q,coe_k))
    coe_k = np.zeros((1,21))
    Q = np.vstack((Q,coe_k)) # New row and column for risk free asset
    
    Atilde = []
    for k in range(20):
        Atilde.append([[0,1],[diff[k],1]])
    Atilde.append([[0,1],[0,-1]]) 
    
    cpx = cplex.Cplex()
    cpx.objective.set_sense(cpx.objective.sense.minimize)
    c  = [0.0] * n
    lb = [0.0] * n
    ub = [np.inf] * n 
    
    var_names = ['y_%s'% i for i in range(1,n+1)]
    cpx.linear_constraints.add(rhs=[1.0,0],senses='EE')
    cpx.variables.add(obj=c,lb=lb,ub=ub,columns=Atilde,names=var_names)

    qmat = [[list(range(n)), list(2*Q[k,:])] for k in range(n)]
    cpx.objective.set_quadratic(qmat) # Quadratic objective
    cpx.parameters.threads.set(6)
    cpx.set_results_stream(None)
    cpx.set_warning_stream(None)
    cpx.solve()

    # If no optimal solution exists, do not rebalance
    # Keep the position and cash from last period
    if cpx.solution.get_status_string() == 'infeasible':
        x_optimal = x_init
        cash_optimal = cash_init
    
    else:
        w_maxSharpe = np.array(cpx.solution.get_values()) # Optimal weight                        
        weight = w_maxSharpe[0:20]/w_maxSharpe[20]
    
        allocated_value = weight*total_value
  
        x_optimal = np.floor(allocated_value/cur_prices) # Rounding procedure
        transaction_fee = 0.005 * np.dot(cur_prices,abs(x_optimal-x_init))
        cash_optimal = total_value - np.dot(cur_prices,x_optimal) - transaction_fee
    
        cash_optimal = total_value - np.dot(cur_prices,x_optimal) - transaction_fee
    
    return x_optimal, cash_optimal

def strat_equal_risk_contr(x_init, cash_init, mu, Q, cur_prices):
    
    portfolio_value = np.dot(cur_prices,x_init) + cash_init
    
    class erc(object):
        def __init__(self):
            pass

        def objective(self, x):
            # The callback for calculating the objective
            y = x * np.dot(Q, x)
            fval = 0
            for i in range(n):
                for j in range(i,n):
                    xij = y[i] - y[j]
                    fval = fval + xij*xij
            fval = 2*fval
            return fval

        def gradient(self, x):
            # The callback for calculating the gradient
            grad = np.zeros(n)
            y = x * np.dot(Q, x)
            #  use finite differences to check the gradient
            for i in range(n):
                for j in range(n):
                    diff1 = np.dot(Q[i],x) + np.dot(Q[i][i],x[i])
                    diff2 = np.dot(Q[i][j], x[i])
                    delta_g = (y[i]-y[j]) * (diff1 - diff2)
                    grad[i] = grad[i] + delta_g
                grad[i] = 2 * 2 * grad[i]
            return grad

        def constraints(self, x):
        # The callback for calculating the constraints
            return [1.0] * n
    
        def jacobian(self, x):
        # The callback for calculating the Jacobian
            return np.array([[1.0] * n])
    
    n = len(x_init)
    w0 = (x_init*cur_prices)/portfolio_value # initial weight distribution
    lb = [0.0] * n  # lower bounds on variables
    ub = [1.0] * n  # upper bounds on variables
    cl = [1]        # lower bounds on constraints
    cu = [1]        # upper bounds on constraints
    
    
    # Define IPOPT problem
    nlp = ipopt.Problem(n=len(w0), m=len(cl), problem_obj=erc(), lb=lb, ub=ub, cl=cl, cu=cu)
    
    # Set the IPOPT options
    nlp.add_option('jac_c_constant'.encode('utf-8'), 'yes'.encode('utf-8'))
    nlp.add_option('hessian_approximation'.encode('utf-8'), 'limited-memory'.encode('utf-8'))
    nlp.add_option('mu_strategy'.encode('utf-8'), 'adaptive'.encode('utf-8'))
    nlp.add_option('tol'.encode('utf-8'), 1e-10)
    w_optimal, info = nlp.solve(w0)
    
    allocated_money = w_optimal * portfolio_value
    x_optimal = np.floor(allocated_money/cur_prices)   #Rounding procedure       
    transaction_fee = np.dot(cur_prices, abs(x_optimal-x_init))*0.005               #0.5% of transaction cost
    cash_optimal = portfolio_value - np.dot(cur_prices,x_optimal) - transaction_fee #cash = asset - stock value- transaction cost
 
    return x_optimal, cash_optimal

def strat_lever_equal_risk_contr(x_init, cash_init, mu, Q, cur_prices):
    #Use IPOPT solver to calculate equal risk contribution
    class erc(object):
        def __init__(self):
            pass

        def objective(self, x):
            # The callback for calculating the objective
            y = x * np.dot(Q, x)
            fval = 0
            for i in range(n):
                for j in range(n):
                    xij = y[i] - y[j]
                    fval = fval + xij*xij
            fval = 2*fval
            return fval

        def gradient(self, x):
            # The callback for calculating the gradient
            grad = np.zeros(n)
            y = x * np.dot(Q, x)
            #use finite differences to check the gradient
            for i in range(n):
                for j in range(n):
                    diff1 = np.dot(Q[i],x) + np.dot(Q[i][i],x[i])
                    diff2 = np.dot(Q[i][j], x[i])
                    delta_g = (y[i]-y[j]) * (diff1 - diff2)
                    grad[i] = grad[i] + delta_g
                grad[i] = 2 * 2 * grad[i] 
            return grad

        def constraints(self, x):
        # The callback for calculating the constraints
            return [1.0] * n
    
        def jacobian(self, x):
        # The callback for calculating the Jacobian
            return np.array([[1.0] * n])
    
    portfolio_value = np.dot(cur_prices,x_init) + cash_init  
    borrow_value = init_value
    r_rf2008_2009 = 0.045
    interest = borrow_value*r_rf2008_2009/6
    
    if period == 1:
        portfolio_value = portfolio_value + borrow_value        #200% long position in the beginning
    
    n = len(x_init)
    lb = [0.0] * n  # lower bounds on variables
    ub = [1.0] * n  # upper bounds on variables
    cl = [1]        # lower bounds on constraints
    cu = [1]        # upper bounds on constraints
    w0 = (x_init*cur_prices)/portfolio_value
    # Define IPOPT problem
    nlp = ipopt.Problem(n=len(w0), m=len(cl), problem_obj=erc(), lb=lb, ub=ub, cl=cl, cu=cu)
    
    # Set the IPOPT options
    nlp.add_option('jac_c_constant'.encode('utf-8'), 'yes'.encode('utf-8'))
    nlp.add_option('hessian_approximation'.encode('utf-8'), 'limited-memory'.encode('utf-8'))
    nlp.add_option('mu_strategy'.encode('utf-8'), 'adaptive'.encode('utf-8'))
    nlp.add_option('tol'.encode('utf-8'), 1e-10)
    w_lerc, info = nlp.solve(w0)
    w_lerc = np.array(w_lerc)
    w_optimal = w_lerc*(1/w_lerc.sum())
    
    allocated_money = w_optimal*portfolio_value
    x_optimal = np.floor(allocated_money/cur_prices)                                 #Rounding procedure        
    transaction_fee = np.dot(cur_prices, abs(x_optimal-x_init))*0.005               #0.5% of transaction cost
    cash_optimal = portfolio_value - np.dot(x_optimal,cur_prices) - transaction_fee - interest #cash = asset - stock value- transaction cost

    return x_optimal, cash_optimal

def strat_robust_optim(x_init, cash_init, mu, Q, cur_prices):
    portfolio_value = np.dot(cur_prices,x_init) + cash_init
    n = len(x_init)
    w0 = [1/n]*n                                         # Weight distribution for 1/n portfolio
    var_matr = np.diag(np.diag(Q))                           # Required portfolio robustness
    rob_init = np.dot(w0, np.dot(var_matr, w0))              # return estimation error of 1/n portfolio
    rob_bnd  = rob_init                                      # Target portfolio return estimation error is return estimation error of 1/n portfolio
    daily_rf = r_rf2008_2009/252                             # Use 2008-2009 risk free rate
    Portf_Retn = daily_rf                                  
    
    cpx = cplex.Cplex()
    cpx.objective.set_sense(cpx.objective.sense.minimize)
    
    
    c  = [0.0] * n
    lb = [0.0] * n
    ub = [1.0] * n
    Atilde = []
    for k in range(n):
        Atilde.append([[0,1],[1.0,mu[k]]])
    var_names = ["w_%s" % i for i in range(1,n+1)]
    
    cpx.linear_constraints.add(rhs=[1.0,Portf_Retn], senses="EG")
    cpx.variables.add(obj=c, lb=lb, ub=ub, columns=Atilde, names=var_names)
    Qmat = [[list(range(n)), list(2*Q[k,:])] for k in range(n)]
    cpx.objective.set_quadratic(Qmat)
    Qcon = cplex.SparseTriple(ind1=var_names, ind2=range(n), val=np.diag(var_matr))
    cpx.quadratic_constraints.add(rhs=rob_bnd, quad_expr=Qcon, name="Qc")
    cpx.parameters.threads.set(4)
    cpx.parameters.timelimit.set(60)
    cpx.parameters.barrier.qcpconvergetol.set(1e-12)
    cpx.set_results_stream(None)
    cpx.set_warning_stream(None)
    cpx.solve()

    # If no optimal solution exists, do not rebalance
    # Keep the position and cash from last period
    if cpx.solution.get_status_string() == 'infeasible':
        x_optimal = x_init
        cash_optimal = cash_init
    
    else:
    
        w_rMV = cpx.solution.get_values()
        # Round near-zero portfolio weights
        w_rMV = np.array(w_rMV)
        w_rMV[w_rMV<1e-6] = 0
        w_optimal = w_rMV / np.sum(w_rMV)
    
        allocated_money = w_optimal*portfolio_value
        x_optimal = np.floor(allocated_money/cur_prices)                                 #Rounding procedure
        transaction_fee = np.dot(cur_prices, abs(x_optimal-x_init))*0.005                #0.5% of transaction cost
        cash_optimal = portfolio_value - np.dot(x_optimal,cur_prices) - transaction_fee #cash = asset - stock value- transaction cost

    return x_optimal, cash_optimal

# Input file
input_file_prices = 'Daily_closing_prices20082009.csv'

# Read data into a dataframe
df = pd.read_csv(input_file_prices)

# Convert dates into array [year month day]
def convert_date_to_array(datestr):
    temp = [int(x) for x in datestr.split('/')]
    return [temp[-1], temp[0], temp[1]]

dates_array = np.array(list(df['Date'].apply(convert_date_to_array)))
data_prices = df.iloc[:, 1:].to_numpy()
dates = np.array(df['Date'])
# Find the number of trading days in Nov-Dec 2007 and
# compute expected return and covariance matrix for period 1
day_ind_start0 = 0
day_ind_end0 = len(np.where(dates_array[:,0]==2007)[0])
cur_returns0 = data_prices[day_ind_start0+1:day_ind_end0,:] / data_prices[day_ind_start0:day_ind_end0-1,:] - 1
mu = np.mean(cur_returns0, axis = 0)
Q = np.cov(cur_returns0.T)

# Remove datapoints for year 2008
data_prices = data_prices[day_ind_end0:,:]
dates_array = dates_array[day_ind_end0:,:]
dates = dates[day_ind_end0:]

# Initial positions in the portfolio
init_positions = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 902, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17500])

# Initial value of the portfolio
init_value = np.dot(data_prices[0,:], init_positions)
print('\nInitial portfolio value = $ {}\n'.format(round(init_value, 2)))

# Initial portfolio weights
w_init = (data_prices[0,:] * init_positions) / init_value

# Number of periods, assets, trading days
N_periods = 6*len(np.unique(dates_array[:,0])) # 6 periods per year
N = len(df.columns)-1
N_days = len(dates)

# Annual risk-free rate for years 2020-2021 is 2.5%
r_rf = 0.025
# Annual risk-free rate for years 2008-2009 is 4.5%
r_rf2008_2009 = 0.045

# Number of strategies
strategy_functions = ['strat_buy_and_hold', 'strat_equally_weighted', 'strat_min_variance', 'strat_max_Sharpe', 'strat_equal_risk_contr', 'strat_lever_equal_risk_contr', 'strat_robust_optim']
strategy_names     = ['Buy and Hold', 'Equally Weighted Portfolio', 'Mininum Variance Portfolio', 'Maximum Sharpe Ratio Portfolio', 'Equal Risk Contributions Portfolio', 'Leveraged Equal Risk Contributions Portfolio', 'Robust Optimization Portfolio']
#N_strat = 1  # comment this in your code
N_strat = len(strategy_functions)  # uncomment this in your code
fh_array = [strat_buy_and_hold, strat_equally_weighted, strat_min_variance, strat_max_Sharpe, strat_equal_risk_contr, strat_lever_equal_risk_contr, strat_robust_optim]

print('Initial portfolio value = $ {}'.format(round(init_value, 2)))
portf_value = [0] * N_strat
x = np.zeros((N_strat, N_periods),  dtype=np.ndarray)
cash = np.zeros((N_strat, N_periods),  dtype=np.ndarray)
for period in range(1, N_periods+1):
   # Compute current year and month, first and last day of the period
    if dates_array[0, 0] == 8:
        cur_year  = 8 + math.floor(period/7)
    else:
        cur_year  = 2008 + math.floor(period/7)

    cur_month = 2*((period-1)%6) + 1
    day_ind_start = min([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month)) if val])
    day_ind_end = max([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month+1)) if val])
    print('\nPeriod {0}: start date {1}, end date {2}'.format(period, dates[day_ind_start], dates[day_ind_end]))
   
   # Prices for the current day
    cur_prices = data_prices[day_ind_start,:]

   # Execute portfolio selection strategies
    for strategy  in range(N_strat):

      # Get current portfolio positions
        if period == 1:
            curr_positions = init_positions
            curr_cash = 0
            portf_value[strategy] = np.zeros((N_days, 1))
        else:
            curr_positions = x[strategy, period-2]
            curr_cash = cash[strategy, period-2]

      # Compute strategy
        x[strategy, period-1], cash[strategy, period-1] = fh_array[strategy](curr_positions, curr_cash, mu, Q, cur_prices)

      # Verify that strategy is feasible (you have enough budget to re-balance portfolio)
      # Check that cash account is >= 0
      # Check that we can buy new portfolio subject to transaction costs

      ###################### Insert your code here ############################
        if cash[strategy][period-1]<0 :
            if cash[5,0]<0:  
                portfolio_value = (np.dot(curr_positions,cur_prices) + curr_cash)*2  
                # 200% long positon in the beginning for leveraged ERC
            else:
                portfolio_value = np.dot(curr_positions,cur_prices) + curr_cash       
                #Portfolio value before the balance strategy
                
            weight = (cur_prices * x[strategy, period-1])/portfolio_value
            excess_cash = abs(cash[strategy, period-1])*weight
            excess_stock = np.ceil(excess_cash/cur_prices) # The units of stocks need to sell
            x[strategy, period-1] = x[strategy, period-1] - excess_stock # New optimal protfolio
            new_tran_fee = np.dot(cur_prices , abs(x[strategy, period-1]-curr_positions)) * 0.005
            
            if strategy ==5:                                     #Interest cost related to LERC needs to be considered
                cash[strategy, period-1] = portfolio_value - np.dot(cur_prices,x[strategy][period-1]) - new_tran_fee - init_value*r_rf2008_2009/6
            else:
                cash[strategy, period-1] = portfolio_value - np.dot(cur_prices,x[strategy][period-1]) - new_tran_fee


      # Compute portfolio value
        # p_values = np.dot(data_prices[day_ind_start:day_ind_end+1,:], x[strategy, period-1]) + cash[strategy, period-1]
        # portf_value[strategy][day_ind_start:day_ind_end+1] = np.reshape(p_values, (p_values.size,1))
        # print('  Strategy "{0}", value begin = $ {1:.2f}, value end = $ {2:.2f}'.format( strategy_names[strategy], 
        #      portf_value[strategy][day_ind_start][0], portf_value[strategy][day_ind_end][0]))
        p_values = np.dot(data_prices[day_ind_start:day_ind_end+1,:], x[strategy, period-1]) + cash[strategy, period-1]
        if strategy ==5: # if using leveraged equal risk contributions strategy
            portf_value[strategy][day_ind_start:day_ind_end+1] = np.reshape(p_values, (p_values.size,1)) - init_value
        else:
            portf_value[strategy][day_ind_start:day_ind_end+1] = np.reshape(p_values, (p_values.size,1))
        print('  Strategy "{0}", value begin = $ {1:.2f}, value end = $ {2:.2f}'.format( strategy_names[strategy], 
             portf_value[strategy][day_ind_start][0], portf_value[strategy][day_ind_end][0]))

      
   # Compute expected returns and covariances for the next period
    cur_returns = data_prices[day_ind_start+1:day_ind_end+1,:] / data_prices[day_ind_start:day_ind_end,:] - 1
    mu = np.mean(cur_returns, axis = 0)
    Q = np.cov(cur_returns.T)

plt.figure(figsize=(16,12))
plt.plot(portf_value[0],label='Buy and Hold')
plt.plot(portf_value[1],label='Equally Weighted')
plt.plot(portf_value[2],label='Minimum Variance')
plt.plot(portf_value[3],label='Maximum Sharpe Ratio')
plt.plot(portf_value[4],label='Equal Risk contribution')
plt.plot(portf_value[5],label='Leveraged Equal Risk Contribution')
plt.plot(portf_value[6],label='Robust Mean Variance')
plt.legend()
plt.title('Figure 6: Daily Portfolio Values for Each Strategy')
plt.xlabel('Time')
plt.ylabel('Portfolio Values')
plt.savefig('Daily Portfolio Values for Each Strategy.png')
plt.show()

MDD = []
for period in range(1, N_periods+1):
    if dates_array[0, 0] == 8:
        cur_year  = 8 + math.floor(period/7)
    else:
        cur_year  = 2008 + math.floor(period/7)

    cur_month = 2*((period-1)%6) + 1
    day_ind_start = min([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month)) if val])
    day_ind_end = max([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month+1)) if val])

    m = []
    for i in range(7):
      m = []
    for i in range(7):
      index = portf_value[i][day_ind_start:day_ind_end+1].argmin() # The index of tough point
      # Compute Maximum Drawdown
      mdd = ((min(portf_value[i][day_ind_start:day_ind_end+1])-max(portf_value[i][day_ind_start:day_ind_start+index+1]))/max(portf_value[i][day_ind_start:day_ind_start+index+1]))*100
      mdd = abs(mdd)
      m.append(mdd) 
    MDD.append(m)

Max_drawdown = pd.DataFrame()
for i in range(12):
  a = [j for sub in MDD[i] for j in sub]
  Max_drawdown[i+1] = a
Max_drawdown = Max_drawdown.transpose()
Max_drawdown = Max_drawdown.rename(columns={0: "Buy and hold", 1: "Equally weighted", 2: "Minimum variance", 3: "Maximum Sharpe ratio", 4: "Equal risk contributions", 5: "Leveraged equal risk contributions", 6: "Robust optimization"})
Max_drawdown.plot(figsize=(16,12))
plt.title('Figure 7: Maximum Drawdowns of Portfolios for Seven Strategies')
plt.xlabel('Period')
plt.ylabel('Maximum drawdown (%)')
plt.show()

assets = list(df.columns.values)
assets = assets[1:]

trading_period = np.arange(0,13,1)

w_init = (data_prices[0,:]*init_positions)/init_value

x[6, period-1], cash[6, period-1]= fh_array[6](curr_positions, curr_cash, mu, Q, cur_prices)

asset_weight =[]
asset_weight.append(w_init)
for period in range(1, N_periods+1):
    if dates_array[0, 0] == 8:
        cur_year  = 8 + math.floor(period/7)
    else:
        cur_year  = 2008 + math.floor(period/7)

    cur_month = 2*((period-1)%6) + 1
    day_ind_start = min([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month)) if val])
    day_ind_end = max([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month+1)) if val])

    # Prices for the current day
    cur_prices = data_prices[day_ind_start,:]
    
    total_value = np.dot(cur_prices,x[6, period-1])
    asset_weight.append((cur_prices*x[6, period-1])/total_value)
    
df_minvar = pd.DataFrame(asset_weight,columns = assets)

df_minvar.plot(figsize=(16,12),cmap="tab20")
plt.title('Figure 8: Dynamic Change with robust mean variance Strategy')
plt.xlabel('Periods')
plt.ylabel('Weights of Portfolio')
plt.legend(loc='upper right', ncol = 5)
plt.show()

# Dynamic change of minimum variance
assets = list(df.columns.values)
assets = assets[1:]

trading_period = np.arange(0,13,1)

w_init = (data_prices[0,:]*init_positions)/init_value

x[2, period-1], cash[2, period-1]= fh_array[2](curr_positions, curr_cash, mu, Q, cur_prices)

asset_weight =[]
asset_weight.append(w_init)

# Calculate weight of each protfolio
for period in range(1, N_periods+1):
    if dates_array[0, 0] == 8:
        cur_year  = 8 + math.floor(period/7)
    else:
        cur_year  = 2008 + math.floor(period/7)

    cur_month = 2*((period-1)%6) + 1
    day_ind_start = min([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month)) if val])
    day_ind_end = max([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month+1)) if val])

    # Prices for the current day
    cur_prices = data_prices[day_ind_start,:]
    
    total_value = np.dot(cur_prices,x[2, period-1])
    asset_weight.append((cur_prices*x[2, period-1])/total_value)
    
df_minvar = pd.DataFrame(asset_weight,columns = assets)

df_minvar.plot(figsize=(16,12),cmap="tab20")
plt.title('Figure 9: Dynamic Change with Minimum Variance Portfolio Strategy')
plt.xlabel('Periods')
plt.ylabel('Weights of Portfolio')
plt.legend(loc='upper right', ncol = 5)
plt.savefig('Dynamic Change Minimum Variance.png')
plt.show()

# Dynamic change of maximum Sharpe ratio
x[3, period-1], cash[3, period-1] = fh_array[3](curr_positions, curr_cash, mu, Q, cur_prices)

asset_weight_3 =[]
asset_weight_3.append(w_init)
# Calculate weight of each protfolio
# Because of the rounding procedure, the weight might not be exactly 1, but very close to 1
for period in range(1, N_periods+1):
    if dates_array[0, 0] == 8:
        cur_year  = 8 + math.floor(period/7)
    else:
        cur_year  = 2008 + math.floor(period/7)

    cur_month = 2*((period-1)%6) + 1
    day_ind_start = min([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month)) if val])
    day_ind_end = max([i for i, val in enumerate((dates_array[:,0] == cur_year) & (dates_array[:,1] == cur_month+1)) if val])

    cur_prices = data_prices[day_ind_start,:]
    
    total_value = np.dot(cur_prices,x[3, period-1])
    asset_weight_3.append((cur_prices*x[3, period-1])/total_value)

df_maxsharpe = pd.DataFrame(asset_weight_3,columns = assets,index=trading_period)

df_maxsharpe.plot(figsize=(16,12),cmap="tab20")
plt.title('Figure 10: Dynamic Change with Maximum Sharpe Ratio Portfolio Strategy')
plt.xlabel('Periods')
plt.ylabel('Weights of Portfolio')
plt.legend(loc='upper right', ncol = 5)
plt.savefig('Dynamic Change Maximun Sharpe.png')
plt.show()